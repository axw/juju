// Copyright 2016 Canonical Ltd.
// Licensed under the AGPLv3, see LICENCE file for details.

package controller

import (
	"fmt"
	"net/url"

	"github.com/juju/errors"
	"github.com/juju/loggo"
	"github.com/juju/schema"
	"github.com/juju/utils"
	"gopkg.in/macaroon-bakery.v1/bakery"

	"github.com/juju/juju/cert"
)

var logger = loggo.GetLogger("juju.controller")

const (
	// APIPortKey is the port used for api connections.
	APIPortKey = "api-port"

	// StatePortKey is the port used for mongo connections.
	StatePortKey = "state-port"

	// CACertKey is the key for the controller's CA certificate attribute.
	CACertKey = "ca-cert"

	// ControllerUUIDKey is the key for the controller UUID attribute.
	ControllerUUIDKey = "controller-uuid"

	// IdentityURLKey sets the url of the identity manager.
	IdentityURLKey = "identity-url"

	// IdentityPublicKeyKey sets the public key of the identity manager.
	IdentityPublicKeyKey = "identity-public-key"

	// SetNumaControlPolicyKey stores the value for this setting
	SetNumaControlPolicyKey = "set-numa-control-policy"
)

const (
	// Attribute Defaults

	// DefaultNumaControlPolicy should not be used by default.
	// Only use numactl if user specifically requests it
	DefaultNumaControlPolicy = false

	// DefaultStatePort is the default port the controller is listening on.
	DefaultStatePort int = 37017

	// DefaultApiPort is the default port the API server is listening on.
	DefaultAPIPort int = 17070
)

// ControllerOnlyConfigAttributes are attributes which are only relevant
// for a controller, never a model.
var ControllerOnlyConfigAttributes = []string{
	APIPortKey,
	StatePortKey,
	CACertKey,
	ControllerUUIDKey,
	IdentityURLKey,
	IdentityPublicKeyKey,
	SetNumaControlPolicyKey,
}

// ControllerOnlyAttribute returns true if the specified attribute name
// is only relevant for a controller.
func ControllerOnlyAttribute(attr string) bool {
	for _, a := range ControllerOnlyConfigAttributes {
		if attr == a {
			return true
		}
	}
	return false
}

// Config contains controller-specific configuration.
type Config struct {
	// APIPort is the port used for api connections.
	APIPort int

	// StatePort is the port used for mongo connections.
	StatePort int

	// UUID is the controller's UUID.
	UUID string

	// CACert is the controller's CA certificate, in PEM format.
	CACert string

	// IdentityURL is the URL of the controller's identity manager,
	// if any.
	IdentityURL string

	// IdentityPublicKey is the public key of the controller's identity
	// manager, if any, in the text format of bakery.PublicKey.
	IdentityPublicKey string

	// SetNumaControlPolicy records the controller's policy for using
	// "numactl" when starting mongod.
	SetNumaControlPolicy bool
}

// Validate validates the controller configuration.
func (c Config) Validate() error {
	if c.APIPort <= 0 || c.APIPort > 65535 {
		return errors.NewNotValid(nil, fmt.Sprintf("%s %d out of range", APIPortKey, c.APIPort))
	}
	if c.StatePort <= 0 || c.StatePort > 65535 {
		return errors.NewNotValid(nil, fmt.Sprintf("%s %d out of range", StatePortKey, c.StatePort))
	}
	if !utils.IsValidUUIDString(c.UUID) {
		return errors.NotValidf("%s %q", ControllerUUIDKey, c.UUID)
	}
	if _, err := cert.ParseCert(c.CACert); err != nil {
		return errors.Annotate(err, "validating "+CACertKey)
	}
	if c.IdentityURL != "" {
		if c.IdentityPublicKey == "" {
			return errors.NewNotValid(nil, fmt.Sprintf(
				"%s is set, but %s is not", IdentityURLKey, IdentityPublicKeyKey,
			))
		}

		url, err := url.Parse(c.IdentityURL)
		if err != nil {
			return errors.NewNotValid(err, IdentityURLKey+" not valid")
		}
		if url.Scheme != "https" {
			return errors.NewNotValid(nil, IdentityURLKey+" must be an HTTPS URL")
		}

		var pubKey bakery.PublicKey
		if err := pubKey.UnmarshalText([]byte(c.IdentityPublicKey)); err != nil {
			return errors.NewNotValid(err, IdentityPublicKeyKey+" not valid")
		}
	} else if c.IdentityPublicKey != "" {
		return errors.NewNotValid(nil, fmt.Sprintf(
			"%s is set, but %s is not", IdentityPublicKeyKey, IdentityURLKey,
		))
	}
	return nil
}

// NewConfig creates a new Config from the supplied attributes.
// Default values will be used where defaults are available.
//
// The controller UUID and CA certificate must be passed in.
// The UUID is typically generated by the immediate caller,
// and the CA certificate generated by environs/bootstrap.NewConfig.
func NewConfig(uuid, caCert string, attrs map[string]interface{}) (Config, error) {
	coerced, err := configChecker.Coerce(attrs, nil)
	if err != nil {
		return Config{}, errors.Trace(err)
	}
	attrs = coerced.(map[string]interface{})
	config := Config{
		APIPort:              attrs[APIPortKey].(int),
		StatePort:            attrs[StatePortKey].(int),
		UUID:                 uuid,
		CACert:               caCert,
		SetNumaControlPolicy: attrs[SetNumaControlPolicyKey].(bool),
	}
	if identityURL, ok := attrs[IdentityURLKey].(string); ok {
		config.IdentityURL = identityURL
	}
	if identityPublicKey, ok := attrs[IdentityPublicKeyKey].(string); ok {
		config.IdentityPublicKey = identityPublicKey
	}
	return config, config.Validate()
}

// GenerateControllerCertAndKey makes sure that the config has a CACert and
// CAPrivateKey, generates and returns new certificate and key.
func GenerateControllerCertAndKey(caCert, caKey string, hostAddresses []string) (string, string, error) {
	return cert.NewDefaultServer(caCert, caKey, hostAddresses)
}

var configChecker = schema.FieldMap(schema.Fields{
	APIPortKey:              schema.ForceInt(),
	StatePortKey:            schema.ForceInt(),
	IdentityURLKey:          schema.String(),
	IdentityPublicKeyKey:    schema.String(),
	SetNumaControlPolicyKey: schema.Bool(),
}, schema.Defaults{
	APIPortKey:              DefaultAPIPort,
	StatePortKey:            DefaultStatePort,
	IdentityURLKey:          schema.Omit,
	IdentityPublicKeyKey:    schema.Omit,
	SetNumaControlPolicyKey: DefaultNumaControlPolicy,
})
